/**
 * name:		Tetris.js
 * license:		MIT-style license
 * copyright:	Copyright (c) 2012 Andrew Lo <http://cs.ucsb.edu/~andrewlo>
 * version:		1.00
 */

// @@TODO:
// - Add 'Controls' menu item
// - Add more options
// - Clean up canvas measurements and magic numbers
// - Export strings
// - Optimize game calculations
// - Standardise quote usage


// Only expose Tetris to global scope (window.Tetris)
(function (global) {

	//
	// Core Game object. Runs functions implemented in game state objects.
	//
	var Tetris = (function () {
		var
			data = {
				currRender:		null,
				gameLoop:		null,
				newRender:		'Tetris.Menu', // Signals state change

				canvas:			null
			};

		return {
			version: '1.00',
			settings: {
				bodyFont: 'Life Savers',
				fps: 200,
				ghost: true,
				headerFont: 'Rye',
				imgBlock: true,
				size: { h: 22, w: 10 },
				speed: 250,

				canvas: 'gameCnvs'
			},

			get: function (key) {
				return data[key];
			},
			// Send event obj to game state's handleKeys() method
			handleKeys: function (evt) {
				data.currRender.handleKeys(evt);
			},
			initialize: function () {
				data.canvas = $(this.settings.canvas);

				window.addEvent('keydown', this.handleKeys);
				// Save CPU cycles if window is not active
				window.addEvent('blur', this.pause.bind(this, true));
				window.addEvent('focus', this.pause.bind(this, false));

				this.pause(false);
			},
			pause: function (paused) {
				if (paused) {
					clearInterval(data.gameLoop);
				} else {
					data.gameLoop =
						this.render.periodical(1000 / this.settings.fps, this);
				}
			},
			// Check for window resize, updated state. Runs render method of
			//   current game state.
			render: function () {
				var
					ctx = data.canvas.getContext('2d'),
					cnvsSize = Math.min(window.innerHeight, window.innerWidth);

				data.canvas.height = data.canvas.width = cnvsSize;

				// Check for updated state
				if (data.newRender) {
					var
						scope	=	global,
						levels	=	data.newRender.split('.');

					for (var i = 0; i < levels.length; i++) {
						scope = scope[levels[i]];
					}
					data.currRender	=	scope;
					data.newRender	=	null;

					data.currRender.initialize.call(data.currRender);
				}

				data.currRender.render.call(data.currRender);
			},
			set: function (key, val) {
				data[key] = val;
				return this;
			}
		};
	}) ();
	global.Tetris = Tetris;

	// Represents a single Tetrinimo
	// Store layouts in BlockFactory so data is only initialized once
	var Block = (function (proto) {
		var data = {
			layout: null,
			pos: {
				x: 0,
				y: 0
			},
			type: null
		};
		data.type = proto.type;

		var layout = data.layout = [];
		for (var i = 0, j = proto.layout, k = j.length; i < k; i++) {
			layout[i] = [];
			for (var p = 0, q = j[i], r = q.length; p < r; p++) {
				layout[i][p] = q[p];
			}
		}

		data.pos.x =
			Math.floor((Tetris.settings.size.w - layout[0].length) / 2);


		return {
			get: function (key) {
				return data[key];
			},
			set: function (key, val) {
				data[key] = val;
				return this;
			}
		};
	});


	//
	// BlockFactory
	// Provide a copy of a pseudo-randomly selected block type
	//
	var BlockFactory = (function () {
		var
			blockStats		=	null,
			blockQueue		=	[],

			blockLayouts	=	[ // Array of all block layouts
				{
					type:	'O',
					layout:	[
						[false,	false,	false,	false],
						[false,	true,	true,	false],
						[false,	true,	true,	false],
						[false,	false,	false,	false]
					]
				}, {
					type:	'I',
					layout:	[
						[false,	false,	false,	false],
						[false,	false,	false,	false],
						[true,	true,	true,	true],
						[false,	false,	false,	false]
					]
				}, {
					type:	'Z',
					layout:	[
						[true,	true, false],
						[false,	true, true],
						[false,	false, false]
					]
				}, {
					type:	'S',
					layout:	[
						[false,	true, true],
						[true,	true, false],
						[false,	false, false]
					]
				}, {
					type:	'L',
					layout: [
						[true,	false, false],
						[true,	true, true],
						[false,	false, false]
					]
				}, {
					type:	'J',
					layout:	[
						[false,	false, true],
						[true,	true, true],
						[false,	false, false]
					]
				}, {
					type:	'T',
					layout:	[
						[false,	true, false],
						[true,	true, true],
						[false,	false, false]
					]
				}
			];


		function getRandIdx() {
			// Make sure blocks are chosen somewhat more fairly
			var
				minVal,
				minIdx;

			for (var i = 0; i < blockStats.length; i++) {
				var randVal =
						Math.floor(Math.random() * Math.pow(blockStats[i], 3)),
					randOffset = (Math.random() < 0.5) ? 0.5 : -0.5;
				if (!minVal || randVal + randOffset < minVal) {
					minVal = randVal;
					minIdx = i;
				}
			}
			blockStats[minIdx]++;

			return minIdx;
		}
		function pushBlock() {
			blockQueue.unshift(new Block(blockLayouts[getRandIdx()]));
		}

		// Initialize block stats
		blockStats = [];
		for (var i = 0; i < blockLayouts.length; i++) {
			blockStats[i] = 5;
		}

		// Set up blockQueue
		for (var i = 0; i < 3; i++) {
			pushBlock();
		}

		return {
			getQueue: function () {
				return blockQueue;
			},
			popBlock: function () {
				pushBlock();
				return blockQueue.pop();
			}
		};
	}) ();

	//
	// Game States
	// -  Each game state contains initialize() and render() functions.
	//

	var About = {
		handleKeys: function (evt) {
			if (evt.key === 'enter')
				Tetris.set('newRender', 'Tetris.Menu');
		},
		initialize: function () {},
		render: function () {
			var ctx = Tetris.get('canvas').getContext('2d'),
				cH = ctx.canvas.height,
				cW = ctx.canvas.width;

			ctx.fillStyle = '#FFF';
			ctx.fillRect(0, 0, cW, cH);

			ctx.fillStyle = '#333';
			ctx.font = (cH * 0.18) + 'px ' + Tetris.settings.headerFont;
			ctx.fillText('Tetris.js', cW * 0.12, cH * 0.35);

			ctx.fillStyle = '#555';
			ctx.font = (cH * .05) + 'px ' + Tetris.settings.bodyFont;
			ctx.fillText('by andrewlo', cW * .35, cH * 0.45);
			ctx.fillText('version ' + Tetris.version, cW * .35, cH * 0.52);
		}
	};
	Tetris.About = About;

	var GameOver = {
		handleKeys: function (evt) {
			if (evt.key === 'enter') Tetris.set('newRender', 'Tetris.Menu');
		},
		initialize: function () {},
		render: function () {
			var ctx = Tetris.get('canvas').getContext('2d');

			ctx.fillStyle = '#300';
			ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

			ctx.fillStyle = ctx.strokeStyle = '#FFF';
			ctx.fillRect(0, ctx.canvas.height * .35,
					ctx.canvas.width, ctx.canvas.height * .005);

			ctx.lineWidth = 3;
			ctx.font = (ctx.canvas.height * 0.12) + 'px ' +
					Tetris.settings.headerFont;
			ctx.strokeText('GAME OVER', ctx.canvas.width * .1,
					ctx.canvas.height * .35);

			ctx.fillStyle = '#800';
			ctx.lineWidth = 1;
			ctx.font = (ctx.canvas.height * .07) + 'px ' +
					Tetris.settings.headerFont;
			ctx.fillText('PLAY AGAIN?', ctx.canvas.width * .2,
					ctx.canvas.height * .42);
		}
	};
	Tetris.GameOver = GameOver;

	// Main game state.
	var Main = (function () {
		var data = {
			board: null,
			currPiece: null,
			lastAct: 0,
			linesCompleted: 0,
			paused: false,

			stats: {
				fps: '-',
				frames: 0,
				timeStart: new Date().getTime()
			}
		};
		return {
			act: function () {
				if (!this.move({ y: 1 })) {
					var currPos = data.currPiece.get('pos');
					for (var i = 0, j = data.currPiece.get('layout'),
						k = j.length; i < k; i++) {
						for (var p = 0, q = j[i], r = q.length; p < r; p++) {
							if (j[i][p]) {
								data.board[currPos.y + i][currPos.x + p] = true;
							}
						}
					}
					data.currPiece = null;
				}

				for (var i = 0; i < Tetris.settings.size.h; i++) {
					if (i < 2) {
						for (var j = 0, k = data.board[i], l = k.length;
							j < l; j++) {
							if (k[j]) {
								Tetris.set('newRender', 'Tetris.GameOver');
								return false;
							}
						}
					} else {
						var isFull = true;
						for (var j = 0, k = data.board[i], l = k.length;
							j < l; j++) {
							if (!k[j]) {
								isFull = false;
								break;
							}
						}
						if (isFull) {
							data.board.splice(i, 1);
							data.linesCompleted++;
						} else {
							continue;
						}

						var newRow = [];
						for (var i = 0; i < Tetris.settings.size.w; i++) {
							newRow[i] = false;
						}
						data.board.unshift(newRow);
						i--;
					}
				}
			},
			getGhostPos: function () {
				var 
					c			=	0,
					pos			=	data.currPiece.get('pos'),
					validMove	=	true;

				while (validMove) {
					c++;

					for (var i = 0, j = data.currPiece.get('layout'),
							k = j.length; i < k; i++) {
						for (var p = 0, q = j[i], r = q.length; p < r; p++) {
							if (q[p] &&
									(i + pos.y + c >= Tetris.settings.size.h ||
									data.board[i + pos.y + c][p + pos.x])) {
								validMove = false;
							}
						}
					}
				}
				c--;

				return c;
			},
			handleKeys: function(evt) {
				if (evt.code != 27 && data.paused) return;

				switch (evt.code) {
					case 27: // esc
						this.pause(!data.paused);
						data.lastAct = new Date().getTime();
						break;
					case 32: // space
						while (this.move({ y: 1 }));
						this.act();
						data.lastAct = 0;
						break;
					case 37: // left
						this.move({ x: -1 }) &&
								(data.lastAct = new Date().getTime());
						break;
					case 38: // up
						var newLayout = this.rotate();
						if (newLayout.canRot) {
							data.currPiece.set('layout', newLayout.layout);
							data.lastAct = new Date().getTime();
						}
						break;
					case 39: // right
						this.move({ x: 1 }) &&
								(data.lastAct = new Date().getTime());
						break;
					case 40: // down
						this.move({ y: 1 });
						data.lastAct = new Date().getTime();
						break;
				}
			},
			initialize: function () {
				data.board = [];
				data.linesCompleted = 0;
				
				for (var i = 0; i < Tetris.settings.size.h; i++) {
					data.board[i] = [];
					for (var j = 0; j < Tetris.settings.size.w; j++) {
						data.board[i][j] = false;
					}
				}
			},
			move: function (pos) {
				var canMove = true,
					currPos = data.currPiece.get('pos');

				pos.x = pos.x || 0;
				pos.y = pos.y || 0;
				for (var i = 0, j = data.currPiece.get('layout'), k = j.length;
						i < k; i++) {
					for (var p = 0, q = j[i], r = q.length; p < r; p++) {
						if (!q[p]) continue;
						if (currPos.y + i + pos.y >= Tetris.settings.size.h ||
							currPos.x + p + pos.x < 0 ||
							currPos.x + p + pos.x >= Tetris.settings.size.w ||
							data.board[currPos.y + i + pos.y]
									[currPos.x + p + pos.x]) {
							canMove = false;
						}
					}
				}

				canMove &&
					data.currPiece.set('pos', { x: currPos.x + pos.x,
						y: currPos.y + pos.y });

				return canMove;
			},
			pause: function (b) {
				data.paused = b;
			},
			render: function () {
				var
					blockSize,
					currTime	=	new Date().getTime(),
					ctx			=	Tetris.get('canvas').getContext('2d'),
					cH = ctx.canvas.height,
					cW = ctx.canvas.width,
					img = new Element('img', { src: 'img/block.png' });

				data.stats.frames++;
				if ((new Date()).getTime() - data.stats.timeStart > 2000) {
					data.stats.fps = Math.round(data.stats.frames /
						(new Date().getTime() - data.stats.timeStart) * 1000);
					data.stats.frames = 0;
					data.stats.timeStart = new Date().getTime();
				}


				// BG
				ctx.fillStyle = '#FFF';
				ctx.fillRect(0, 0, cW, cH);

				// Header
				ctx.fillStyle = '#555';
				ctx.font = cH  * 0.075 + 'px ' + Tetris.settings.headerFont;
				ctx.fillText('Tetris.js', cW * .04, cH * .125);

				ctx.fillStyle = '#EEE';
				ctx.fillRect(cW * .07, cH * .8, cW * .3, cH * .15);

				ctx.fillStyle = '#555';
				ctx.font = cH * 0.03 + 'px ' + Tetris.settings.bodyFont;
				ctx.fillText('lines cleared: ' + data.linesCompleted,
						cW * .1, cH * .86);

				ctx.fillText('frames/sec: ' + data.stats.fps,
						cW * .1, cH * .91);

				if (!data.paused && data.lastAct +
						Tetris.settings.speed < currTime) {
					if (data.currPiece) {
						this.act();
					} else {
						data.currPiece = BlockFactory.popBlock();
					}

					data.lastAct = currTime;
				}

				blockSize = Math.min(.96 * cH / (Tetris.settings.size.h - 2),
								.56 * cW / Tetris.settings.size.w);

				// Draw block queue
				var
					blockQueue = BlockFactory.getQueue(),
					queueHeight = 1;

				ctx.fillStyle = '#FFF';
				ctx.fillRect(.07 * cW, .22 * cH, cW * .3, cH * .53);
				ctx.strokeStyle = '#CCC';
				ctx.strokeRect(.07 * cW, .22 * cH, cW * .3, cH * .53);

				ctx.fillStyle = '#888';
				ctx.font = .04 * cH + 'px ' + Tetris.settings.headerFont;
				ctx.fillText('Next:', .09 * cW, .22 * cH - 2);

				ctx.fillStyle = '#333';
				for (var idx = blockQueue.length - 1; idx >= 0; idx--) {
					var
						blockLayout		=	blockQueue[idx].get('layout'),
						nonEmptyRows	=	0;

					for (var i = 0; i < blockLayout.length; i++) {
						var empty = true;
						for (var j = 0, k = blockLayout[i]; j < k.length; j++) {
							if (k[j]) {
								empty = false;
								break;
							}
						}

						if (empty) continue;
						nonEmptyRows++;

						for (var j = 0, k = blockLayout[i]; j < k.length; j++) {
							if (k[j]) {
								ctx.fillRect((cW * .4 - blockLayout.length *
											blockSize) / 2 + blockSize * j,
										cH * .2 + blockSize * queueHeight +
											blockSize * nonEmptyRows, 
										blockSize, blockSize);
								if (Tetris.settings.imgBlock) {
										ctx.drawImage(img,
											(cW * .4 - blockLayout.length *
													blockSize) / 2 + blockSize * j,
												cH * .2 + blockSize * queueHeight +
													blockSize * nonEmptyRows, 
												blockSize, blockSize);
								}
							}
						}
					}

					queueHeight += nonEmptyRows + 1;
				}

				// Draw game board
				ctx.fillStyle = '#FFF';
				ctx.fillRect(.42 * cW, .02 * cH,
						blockSize * Tetris.settings.size.w, .96 * cH);

				ctx.strokeStyle = '#AAA';
				ctx.strokeRect((.42 * cW) - 2,
						.02 * cH - 2,
						blockSize * Tetris.settings.size.w + 4,
						.96 * cH + 4);

				// Draw stationary blocks
				ctx.fillStyle = '#555';
				ctx.strokeStyle = '#FFF';
				for (var i = 0, j = data.board, k = j.length; i < k; i++) {
					for (var p = 0, q = j[i], r = q.length; p < r; p++) {
						if (q[p] && i - 2 >= 0) {
							ctx.fillRect(.42 * cW + blockSize * p,
								.02 * cH + blockSize * (i - 2),
								blockSize, blockSize);
							if (Tetris.settings.imgBlock) {
								ctx.drawImage(img, .42 * cW + blockSize * p,
										.02 * cH + blockSize * (i - 2),
										blockSize, blockSize);
							} else {
								ctx.strokeRect(.42 * cW + blockSize * p,
									.02 * cH + blockSize * (i - 2),
									blockSize, blockSize);
							}
						}
					}
				}

				if (data.currPiece) {
					var
						g	=	this.getGhostPos(),
						x	=	data.currPiece.get('pos').x,
						y	=	data.currPiece.get('pos').y;

					// Draw ghost
					if (Tetris.settings.ghost) {
						ctx.fillStyle = '#DDD';
						for (var i = 0, j = data.currPiece.get('layout'),
								k = j.length; i < k; i++) {
							for (var p = 0, q = j[i], r = q.length; p < r;
									p++) {
								if (y + i + g - 2 >= 0 && q[p]) {
									ctx.fillRect(.42 * cW + blockSize * (x + p),
										.02 * cH + blockSize * (y + i + g - 2),
										blockSize, blockSize);

									if (Tetris.settings.imgBlock) {
										ctx.drawImage(img,
											.42 * cW + blockSize * (x + p),
											.02 * cH + blockSize *
												(y + i + g - 2),
											blockSize, blockSize);
									}
								}
							}
						}
					}

					// Draw piece
					ctx.fillStyle = 'orange';
					ctx.strokeStyle = '#FFF';
					for (var i = 0, j = data.currPiece.get('layout'),
							k = j.length; i < k; i++) {
						for (var p = 0, q = j[i], r = q.length; p < r; p++) {
							if (y + i - 2 >= 0 && q[p]) {
								ctx.fillRect(.42 * cW + blockSize * (x + p),
										.02 * cH + blockSize * (y + i - 2),
										blockSize, blockSize);

								if (Tetris.settings.imgBlock) {
									ctx.drawImage(img,
											.42 * cW + blockSize * (x + p),
											.02 * cH + blockSize * (y + i - 2),
											blockSize, blockSize);
								} else {
									ctx.strokeRect(.42 * cW +
											blockSize * (x + p),
											.02 * cH + blockSize * (y + i - 2),
											blockSize, blockSize);
								}
							}
						}
					}
				}

				// Draw PAUSED message
				if (data.paused) {
					ctx.lineWidth = 4;
					ctx.strokeStyle = '#CCC';
					ctx.strokeRect(0, .27 * cH, cW, cH * .18);

					ctx.fillStyle = '#CCC';
					ctx.fillRect(0, .28 * cH, cW, cH * .16);

					ctx.fillStyle = '#555';
					ctx.font = (0.1 * cH) + 'px ' + Tetris.settings.headerFont;
					ctx.fillText('PAUSED', .25 * cW, .4 * cH);
				}
			},
			// Rotate active block
			rotate: function () {
				var
					blockPos	=	data.currPiece.get('pos'),
					canRot		=	true,
					piece		=	data.currPiece.get('layout'),
					rotPiece	=	[];

				for (var i = 0; i < piece.length; i++) {
					rotPiece[i] = [];
					for (var j = 0; j < piece[i].length; j++) {
						rotPiece[i][j] = piece[piece.length - j - 1][i];

						// Check for valid dims
						rotPiece[i][j] &&
							(blockPos.x + j < 0 ||
							 blockPos.x + j >= Tetris.settings.size.w ||
							 blockPos.y + i >= Tetris.settings.size.h) &&
								(canRot = false);
						// Check for overlap
						rotPiece[i][j] &&
							data.board[blockPos.y + i][blockPos.x + j] &&
								(canRot = false);
					}
				}

				return {
					layout:	rotPiece,
					canRot:	canRot
				};
			}
		};
	}) ();
	Tetris.Main = Main;

	var Menu = (function () {
		var data = {
			options: {
				start: 'Tetris.Main',
				options: 'Tetris.Options',
				about: 'Tetris.About'
			},
			menu: null,
			selIdx: 0
		};
		return {
			initialize: function () {
				data.menu = [];
				for (var option in data.options) {
					if (data.options.hasOwnProperty(option)) {
						data.menu.push(option);
					}
				}
			},
			handleKeys: function (evt) {
				evt.key === 'up' && data.selIdx > 0 && data.selIdx--;
				evt.key === 'down' && data.selIdx < data.menu.length - 1 &&
					data.selIdx++;
				evt.key === 'enter' &&
					Tetris.set('newRender',
							data.options[data.menu[data.selIdx]]);
			},
			render: function () {
				var
					ctx = Tetris.get('canvas').getContext('2d');
					cnvsHeight = ctx.canvas.height,
					cnvsWidth = ctx.canvas.width;

				ctx.fillStyle = '#FFF';
				ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

				ctx.fillStyle = '#333';
				ctx.font = (cnvsHeight * .18) + 'px ' +
						Tetris.settings.headerFont;
				ctx.fillText('Tetris.js', cnvsWidth * .12, cnvsHeight * .35);

				ctx.fillStyle = '#CCC';
				ctx.fillRect(cnvsWidth * .30,
						cnvsHeight * (.42 + 0.1 * data.selIdx),
						cnvsWidth * .5,
						cnvsHeight * .1);

				ctx.fillStyle = '#555';
				ctx.font = (cnvsHeight * .08) + 'px ' +
						Tetris.settings.bodyFont;
				for (var i = 0; i < data.menu.length; i++) {
					ctx.fillText(data.menu[i], cnvsWidth * .35,
							cnvsHeight * .5 + cnvsHeight * .1 * i);
				}
			}
		};
	}) ();
	Tetris.Menu = Menu;

	var Options = (function () {
		var
			data = {
				options: {
					'ghost': {
						label: 'Ghost',
						values: {
							'On': true,
							'Off': false
						}
					},
					'imgBlock': {
						label: 'Use SVG',
						values: {
							'Yes': true,
							'No': false
						}
					},
					'speed': {
						label: 'Speed',
						values: {
							'Slow': 500,
							'Norm': 250,
							'Fast': 100,
						}
					}
				},
				selIdx: 0
			};
		return {
			handleKeys: function (evt) {
				var offset = true;
				switch (evt.code) {
					case 13: // enter
						Tetris.set('newRender', 'Tetris.Menu');
						break;
					case 37: // left
						offset = false;
					case 39: // right
						var
							optName	=	Object.keys(data.options)[data.selIdx],
							optVal	=	data.options[optName];

						for (var idx = 0, vals = Object.values(optVal.values);
								idx < vals.length; idx++) {
							if (vals[idx] === Tetris.settings[optName]) {
								if (!offset && idx > 0) {
									Tetris.settings[optName] = vals[idx - 1];
								} else if (offset && idx < vals.length - 1) {
									Tetris.settings[optName] = vals[idx + 1];
								}
								break;
							}
						}
						break;
					case 38: // up
						(data.selIdx > 0) && data.selIdx--;
						break;
					case 40: // down
						(data.selIdx < Object.keys(data.options).length - 1) &&
								data.selIdx++;
						break;
				}
			},
			initialize: function () {},
			render: function () {
				var
					ctx			=	Tetris.get('canvas').getContext('2d'),
					cH			=	ctx.canvas.height,
					cW			=	ctx.canvas.width,
					optCount	=	0;

				ctx.fillStyle = '#FFF';
				ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

				ctx.strokeStyle = '#CCC';
				ctx.strokeRect(.1 * cW, .2 * cH, cW * .8, cH * .7);

				ctx.fillStyle = '#555';
				ctx.font = (.09 * cH) + 'px ' + Tetris.settings.headerFont;
				ctx.fillText('Options', cW * .15, cH * .20);

				for (var option in data.options) {
					if (data.options.hasOwnProperty(option)) {
						var
							thisOption = data.options[option],
							valCount = 0;

						ctx.font = 'bold ' + (.05 * cH)  + 'px ' +
								Tetris.settings.bodyFont;
						ctx.fillText(thisOption.label + ':',
								cW * .15, cH * .3 + optCount * cH * .08);

						for (var val in thisOption.values) {
							if (thisOption.values.hasOwnProperty(val)) {
								var thisValue = thisOption.values[val];

								ctx.lineWidth = (data.selIdx === optCount) ?
										5 : 1;
								ctx.strokeStyle = '#CCC';
								if (Tetris.settings[option] === thisValue) {
									ctx.strokeRect(.45 * cW +
											.15 * cW * valCount - 2,
										cH * .335 +
											(optCount - 1) * cH * .08 - 1,
										.14 * cW + 4, .05 * cH + 2);
								}

								ctx.fillStyle = '#555';
								ctx.font = (.05 * cH)  + 'px ' +
										Tetris.settings.bodyFont;
								ctx.fillText(val,
										.45 * cW + .15 * cW * valCount,
										cH * .3 + optCount * cH * .08);

								valCount++;
							}
						}

						optCount++;
					}
				}
			}
		};
	}) ();
	Tetris.Options = Options;

}) (this);

